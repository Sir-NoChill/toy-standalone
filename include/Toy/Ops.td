//===- ToyDialect.td - Toy dialect -----------*- tablegen -*-===//
//
// This file is licensed under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//

#ifndef TOY_DIALECT
#define TOY_DIALECT

include "mlir/IR/OpBase.td"
include "mlir/IR/SymbolInterfaces.td"
include "mlir/Interfaces/SideEffectInterfaces.td"
include "mlir/Interfaces/FunctionInterfaces.td"

//===----------------------------------------------------------------------===//
// Toy dialect definition.
//===----------------------------------------------------------------------===//

def Toy_Dialect : Dialect {
    let name = "toy";
    let summary = "A toy out-of-tree MLIR dialect.";
    let description = [{
        This dialect is an example of an out-of-tree MLIR dialect designed to
        illustrate the basic setup required to develop MLIR-based tools without
        working inside of the LLVM source tree.

	This particular dialect also works with the University of Alberta
	CMPUT 415 teaching materials in this repository, including antlr
	integration and mlir-based code generation for a complete language.

	For teaching purposes, we implement the Toy language from the mlir
	[toy tutorial](https://mlir.llvm.org/docs/Tutorials/Toy)
    }];
    let cppNamespace = "::mlir::toy";
}

//===----------------------------------------------------------------------===//
// Toy Op definitions
//===----------------------------------------------------------------------===//
//===----------------------------------------------------------------------===//
// Base standalone operation definition.
//===----------------------------------------------------------------------===//

class Toy_Op<string mnemonic, list<Trait> traits = []> :
        Op<Toy_Dialect, mnemonic, traits>;

//===----------------------------------------------------------------------===//
// ConstantOp
//===----------------------------------------------------------------------===//

def ConstantOp : Toy_Op<"constant", [Pure]> {
  let summary = "Constant operation to define tensors in Toy";
  let description = [{
    The `toy.constant` operation defines a tensor value specified by
    the program input.
    ```mlir
    %0 = "toy.constant"()
       { value = dense<[[1.0, 2.0, 3.0], [4.0, 5.0, 6.0]]> : tensor<2x3xf64> }
      : () -> tensor<2x3xf64>
      ```
  }];

  // The constant op takes one argument (an attribute).
  // `F64ElementsAttr` corresponds to a 64-bit fp ElementsAttr
  // which is a fancy llvm way of specifying an array
  let arguments = (ins F64ElementsAttr:$value);

  // In MLIR, tensors can be first class, so this functino
  // simply outputs a full tensor as an SSA value.
  // `F64Tensor` is a 64-bit fp Tensor Type
  let results = (outs F64Tensor);

  // We specify that this operation has additional verification
  // logic. This is a 'boolean' flag, so setting to 1 will add
  // a declaration (verify()) to our cpp source code in which
  // we can add additional logic. We can also assume that the
  // ODS framework has already verified all the invariants we
  // specified to it (input types, output types, etc).
  let hasVerifier = 1;

  // Now we can specify our custom builders if we require them.
  // If you analyze the output from tblgen, you can see that
  // the ODS framework has already generated the trivial builder
  // so we can use that as a jumping off point
  let builders = [
    // build a constant with a given constant tensor value
    OpBuilder<(ins "DenseElementsAttr":$value), [{
	// call into the autogenerated method
	build($_builder, $_state, value.getType(), value);
    }]>,

    // A custom op builder to build a tensor from a given fp64
    // which will create a definition for us to fill in the header
    OpBuilder<(ins "double":$value)>
  ];

  // Since this is a definition with the type within the attributes
  // we can't just grab the type as we would with functional value
  // inputs, so we need to declare a custom assembly format and
  // write the custom parser ourselves?
  let hasCustomAssemblyFormat = 1;
}

//===----------------------------------------------------------------------===//
// AddOp
//===----------------------------------------------------------------------===//

def AddOp : Toy_Op<"add", [Pure]> {
  let summary = "element-wise addition operation";
  let description = [{
    The "add" operation performs element-wise addition between two tensors.
    The shapes of the tensor operands are expected to match.
  }];
  let arguments = (ins F64Tensor:$lhs, F64Tensor:$rhs);
  let results = (outs F64Tensor);

  // This one we can define declaratively because of functional arguments.
  // We can read more about this type of asm format declaration here:
  // https://mlir.llvm.org/docs/DefiningDialects/Operations/#declarative-assembly-format
  let assemblyFormat = " `(` $lhs `,` $rhs `)` attr-dict `:` `(` type($lhs) `,` type($rhs)`)` `->` type(results)";

  // Allow building an AddOp with from the two input operands.
  let builders = [
    OpBuilder<(ins "Value":$lhs, "Value":$rhs)>
  ];
}

//===----------------------------------------------------------------------===//
// FuncOp
//===----------------------------------------------------------------------===//

def FuncOp : Toy_Op<"func", [Pure, IsolatedFromAbove, FunctionOpInterface]> {
  let summary = "user defined function operation";
  let description = [{
    The "toy.func" operation represents a user defined function. These are
    callable SSA-region operations that contain toy computations.

    Example:

    ```mlir
    toy.func @main() {
      %0 = toy.constant dense<5.500000e+00> : tensor<f64>
      %1 = toy.reshape(%0 : tensor<f64>) to tensor<2x2xf64>
      toy.print %1 : tensor<2x2xf64>
      toy.return
    }
    ```
  }];

  // we get to have some fun here
  let arguments = (ins
    SymbolNameAttr:$sym_name,
    TypeAttrOf<FunctionType>:$function_type,
    OptionalAttr<DictArrayAttr>:$arg_attrs,
    OptionalAttr<DictArrayAttr>:$res_attrs
  );

  let regions = (region AnyRegion:$body);

  let builders = [
    OpBuilder<(ins 
      "StringRef":$name, 
      "FunctionType":$type, 
      CArg<"ArrayRef<NamedAttribute>", "{}">:$attrs)>
  ];

  let extraClassDeclaration = [{
    //===----------------------------------------------------------------------===//
    // FuncionOpInterface Methods
    //===----------------------------------------------------------------------===//
    
    /// returns the argument types of this function.
    ArrayRef<Type> getArgumentTypes() { return getFunctionType().getInputs(); }

    /// Returns the result types of this function.
    ArrayRef<Type> getResultTypes() { return getFunctionType().getResults(); }

    /// Returns the region of the function
    Region *getCallableRegion() { return &getBody(); }
  }];

  let hasCustomAssemblyFormat = 1;
  let skipDefaultBuilders = 1;
}

#endif // TOY_DIALECT
